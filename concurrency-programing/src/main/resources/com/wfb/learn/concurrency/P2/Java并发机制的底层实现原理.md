# Java并发机制的底层实现原理

## volatile关键字

`volatile`关键字保证了共享变量的“可见性”。可见性是指：当一个线程修改一个共享变量时，另一个线程能够读到这个修改的值。它不会引起线程上下文的切换和调度。

### volatile关键字的定义与实现

> Java语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独地获取这个变量。
> Java语言提供了volatile关键字，在某些情况下比锁更加方便。
> 如果一个字段被声明成volatile,Java线程内存模型会确保所有线程看到这个变量的值是一致的。

#### CPU术语定义

| 术语       | 英文单词               | 术语描述                                                                                                           |
| ---------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------ |
| 内存屏障   | memory barriers        | 是一组处理器指令，用于实现对内存操作的顺序限制。                                                                   |
| 原子操作   | atomic operations      | 不可中断的一个或一系列操作。                                                                                       |
| 缓存行     | cache line             | 数据总是以块大小为传送单位在第k层和第k+1层之间来回复制的。这个块被称作缓存块，有时也叫缓存行。                     |
| 缓存行填充 | cache line fill        | 将第k+1层的某个缓存行读取到第k层，叫做缓存行填充。                                                                 |
| 缓存命中   | cache hit              | 当程序需要第k+1层的某个抽象数据d时，它首先在当前存储在第k层的一个块中查找d。如果d刚好缓存在第k层，这就是缓存命中。 |
| 写命中     | write hit              | 我们想要更新的值已经被缓存了，就称为写命中。                                                                       |
| 写缺失     | write misses the cache | 我们想要更新的值没有被缓存，就称为写缺失。                                                                         |

#### volatile的实现原理

查看[VolatileWatch.java](C1/VolatileWatch.java)的JIT汇编代码。我们可以发现`instance = new Singleton();`对应的字节码`putstatic`被翻译成了`movb $0x0, (%rax, %rdi, 1)`和`lock addl $0x0, (%rsp)`两条汇编指令。

`lock`前缀的汇编指令在多核处理器上会引发两件事情：

1. 将当前处理器缓存行的数据写回到系统内存
2. 使其他CPU里缓存了该内存地址的数据无效

在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期。当处理器发现自己缓存行对应的内存地址的数据已过期，就会将该缓存行的有效位置为无效。处理器使用该数据时，会因为缓存失效而被迫从k+1层重新进行缓存行填充。

#### volatile的使用优化

可以通过追加字节填充缓存行，使得两个被volatile修饰的变量处于不同的缓存行，从而优化性能。详见[FillCacheLine.java](C1/FillCacheLine.java)

不过，这种优化方式应 **只使用在共享变量被频繁写** 的时候。因为追加字节的方式意味着需要读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗。如果共享变量不会被频繁地写的话，锁的几率也就非常小了，就没有必要通过追加字节的方式来避免相互锁定了。

### synchronized关键字

Java中的每一个对象都可以作为锁，具体表现为以下三种形式：

1. 对于普通同步方法，锁是当前实例对象
2. 对于静态同步方法，锁是当前类的Class对象
3. 对于同步方法块，锁是synchronized括号里配置的对象

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不太一样。代码块同步显示的使用monitorenter和monitorexit指令实现的，而方法同步隐式的使用了这两个指令。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。

#### Java对象头

synchronized用的锁是存在于Java对象头里的。下面是Java对象头的相关说明：

| 长度     | 内容          | 说明                                                                                            |
| -------- | ------------- | ----------------------------------------------------------------------------------------------- |
| 32/64bit | Mark Word     | 标记字段，用于存储对象自身的运行时数据，如hashCode、分代年龄、锁信息等                          |
| 32/64bit | Class Pointer | 类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例                          |
| 32/32bit | Array Length  | 数组长度，对于数组对象，对象头中增加这一部分，用来记录数组的长度，其长度刚好对应java的int的类型 |

32位虚拟机对象头详情如下：

```text
|--------------------------------------------------------------------------------------------------------------|
|                                          Object Header(64bits)                                               |
|--------------------------------------------------------------------------------------------------------------|
|                    Mark Word(32bits)                           |  Klass Word(32bits)    |      State         |
|--------------------------------------------------------------------------------------------------------------|
|     hashcode:25                   | age:4 | biased_lock:0 | 01 | OOP to metadata object |      Nomal         |
|--------------------------------------------------------------------------------------------------------------|
|     thread:23           | epoch:2 | age:4 | biased_lock:1 | 01 | OOP to metadata object |      Biased        |
|--------------------------------------------------------------------------------------------------------------|
|     ptr_to_lock_record:30                                 | 00 | OOP to metadata object | Lightweight Locked |
|--------------------------------------------------------------------------------------------------------------|
|     ptr_to_heavyweight_monitor:30                         | 10 | OOP to metadata object | Heavyweight Locked |
|--------------------------------------------------------------------------------------------------------------|
|                                                           | 11 | OOP to metadata object |    Marked for GC   |
|--------------------------------------------------------------------------------------------------------------|
```

64位虚拟机对象头详情如下：

```text
|--------------------------------------------------------------------------------------------------------------|
|                                          Object Header(128bits)                                              |
|--------------------------------------------------------------------------------------------------------------|
|                                Mark Word(64bits)               |  Klass Word(64bits)    |      State         |
|--------------------------------------------------------------------------------------------------------------|
| unused:25|identity_hashcode:31|unused:1|age:4|biase_lock:0| 01 | OOP to metadata object |      Nomal         |
|--------------------------------------------------------------------------------------------------------------|
| thread:54|      epoch:2       |unused:1|age:4|biase_lock:1| 01 | OOP to metadata object |      Biased        |
|--------------------------------------------------------------------------------------------------------------|
|                     ptr_to_lock_record:62                 | 00 | OOP to metadata object | Lightweight Locked |
|--------------------------------------------------------------------------------------------------------------|
|                    ptr_to_heavyweight_monitor:62          | 10 | OOP to metadata object | Heavyweight Locked |
|--------------------------------------------------------------------------------------------------------------|
|                                                           | 11 | OOP to metadata object |    Marked for GC   |
|--------------------------------------------------------------------------------------------------------------|
```

其中，各个字段含义如下：

- flag：标记位，为最小的两个bit
- biase_lock：是否为偏向锁，只占1个bit，值为1表示是偏向锁
- age：4bit的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。
- identity_hashcode：25位的对象标识Hash码，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。
- thread：持有偏向锁的线程ID。
- epoch：偏向时间戳。
- ptr_to_lock_record：指向栈中锁记录的指针。
- ptr_to_heavyweight_monitor：指向管程Monitor的指针。

实际状态由标志位和偏向位确定，如下所示：

| biased_lock | lock | 状态                         |
| ----------- | ---- | ---------------------------- |
| 0           | 01   | 无锁(Nomal)                  |
| 1           | 01   | 偏向锁(Biased)               |
| 0           | 00   | 轻量级锁(Lightweight Locked) |
| 0           | 10   | 重量级锁(Heavyweight Locked) |
| 0           | 11   | GC标记(Marked for GC)        |

可以像[JavaHead.java](C2/JavaHead.java)中的示例那样，使用jol工具包去打印想要查看的对象或类的内存使用。

#### 锁的升级与对比

Java6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java6中，锁一共有4中状态，级别从低到高依次为：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁只能升级不可以降级，这样设计的目的是为了提高获得锁和释放锁的效率。

##### 偏向锁

> 在大多数情况下，锁不仅不会被竞争，而且总是有同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的`线程ID`,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标识是否设置成1(表示当前是偏向锁)：如果没有设置，则使用CAS竞争锁; 否则，尝试使用CAS将偏向锁指向当前线程。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以只有当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否已退出同步块：如果线程已退出同步块，则将对象头设置成无锁状态;如果线程仍然处于同步块中，则锁会进行升级处理。

偏向锁在Java8中默认开启，也即默认为`-XX:+UseBiasedLocking`。另外偏向锁默认在3s后才会开启，即`-XX:BiasedLockingStartupDelay=3000`。在未启动偏向锁前创建的对象处于无锁状态;偏向锁启动后创建的对象处于匿名偏向状态(即对象头的thread字段为NULL)。

##### 轻量级锁

线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用CAS将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁; 如果失败，表示其他线程竞争锁，当前线程便自旋继续尝试CAS操作。

轻量级解锁时，会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头，如果成功，则表示没有竞争发生;如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

因为自旋会消耗CPU,为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级成重量级锁，就不会再恢复到轻量级锁的状态。当锁处于重量级时，其他试图获取锁的线程都会被阻塞，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程后进行新的一轮的锁竞争。

##### 锁的优缺点对比

|锁|优点|缺点|适用场景|
|:---:|:---:|:---:|:---:|
|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块的场景|
|轻量级锁|竞争的线程不会阻塞，提高了程序的响应速度|得不到锁的线程会因为自旋空耗CPU资源|追求响应时间，同步块执行速度非常快|
|重量级锁|线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量，同步块执行速度较长|

### 原子操作的实现原理

> 如果这个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是一个原子(atomic)操作。

原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。
将整个操作视作一个整体是原子性的核心特征。

#### 术语定义

术语名称|英文|解释
:---:|:---:|:---:
比较并交换|Compare and Swap|CAS操作需要输入两个值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化，则不交换
CPU流水线|CPU pipeline|CPU流水线就像工业生产上的装配流水线。它是一种试图让CPU的每个单元在每个时钟周期都被使用的技术，大大提高了系统的吞吐量，不过也会轻微地增加延迟
内存顺序冲突|Memory order violation|一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线

#### 处理器如何实现原子操作

所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何`context switch`（切换到另一个线程）。通常所说的原子操作包括对非`long`和`double`型的`primitive`进行赋值，以及返回这两者之外的`primitive`。

在单处理器系统（UniProcessor）中，能够在单条指令中完成的操作都可以认为是" 原子操作"，因为中断只能发生于指令之间。这也是某些CPU指令系统中引入了test_and_set、test_and_clear等指令用于临界资源互斥的原因。但是，在对称多处理器（Symmetric Multi-Processor）结构中就不同了，由于系统中有多个处理器在独立地运行，即使能在单条指令中完成的操作也有可能受到干扰。

处理器会自动保证基本的内存操作的原子性(如：保证从系统内存中读取或写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不会访问这个字节的内存地址。Pentium6和最新的处理器能自动保证但处理器对同一个缓存行里进行16/32/64位的操作是原子的)。但是复杂的内存操作处理器是不能自动保证其原子性的，比如：跨总线宽度、跨多个缓存行和跨页表的访问。为此，处理器有两种机制来保证复杂内存操作的原子性：

1. 使用总线锁保证原子性：如果多个处理器同时对共享变量进行读改写操作(如：典型的i++操作)，因为读改写操作不是原子的，操作完之后共享变量的值会和期望的不一致(如：初始i=0,两个线程都执行了一次i++操作，结果却只是1)。要想保证读改写共享变量的操作是原子的，就必须保证一个CPU读改写共享变量时，其他CPU不能对该共享变量操作。处理器使用总线锁来解决这个问题。所谓总线锁就是一个`LOCK#`信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，从而该处理器可以独占共享内存。(在LOCK#信号出现时，所有读和写操作都不在使用缓存)
2. 使用缓存锁保证原子性：在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可。但总线锁把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存的数据。所以总线锁的开销比较大，目前处理器在某些场合下使用缓存锁替代总线锁来进行优化。

针对以上两种机制，Intel等处理器提供了很多`Lock`前缀的指令。如：位测试和修改指令(`BTS`、`BTR`、`BTC`)、交换指令(`XADD`、`CMPXCHG`)以及其他一些操作数和逻辑指令(`ADD`、`OR`)等。被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

#### Java如何实现原子操作

> 在Java中可以通过锁和循环CAS的方式来实现原子操作。

##### 使用循环CAS实现原子操作

JVM中的CAS操作正是利用了处理器提供的`CMPXCHG`指令实现的。自旋CAS操作的基本思路就是循环进行CAS操作，直到成功为止。详见[CASExample.java](C3/CASExample.java)

在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如`LinkedTransferQueue`类的`xfer`方法。CAS虽然很高效地解决了原子操作，但是仍然存在3大问题：

1. **ABA问题**。如果一个值原来是A,变成了B,又变回了A。那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上值是变化了的。ABA问题的解决思路就是使用版本号或时间戳，每次变量的更新操作都会让版本号加一或者时间戳改变。从Java5开始，JDK的Atomic包提供了一个类`AtomicStampedReference`来解决ABA问题。这个类的`compareAndSet`可以用来解决这个问题

    ```java
    public class AtomicStampedReference<V> {
        public boolean compareAndSet(
            V   expectedReference, // 预期引用
            V   newReference, // 更新后的引用
            int expectedStamp, // 预期标志
            int newStamp // 更新后的标志
        ) {}
    }
    ```

2. **循环时间长开销大**。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的`pause`指令，那么效率会有一定提升。`pause`指令有两个作用：
   1. 它可以延迟流水线执行指令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零
   2. 它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率
3. **只能保证一个共享变量的原子操作**。当一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时可以使用锁。还有一个取巧的办法，那就是把多个共享变量合成一个共享变量来操作。比如：使用不可变对象设计模式，来将多个共享变量合并成一个引用变量。从Java5开始，JDK提供了`AtomicReference`类来保证引用对象的原子性。

##### 使用锁机制实现原子操作

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出时使用循环CAS释放锁。
